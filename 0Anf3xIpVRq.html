<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="en-us" />
<meta name="version" content="4621"/>
<style>body {font-family:Helvetica}ul.comment{list-style-image:url('https://hackpad.com/static/img/comment.png');} ul.task{list-style-image:url('https://hackpad.com/static/img/unchecked.png');}ul.taskdone{list-style-image:url('https://hackpad.com/static/img/checked.png');} </style><title>/1715$0Anf3xIpVRq</title>
</head>
<body><h1></h1><h2>世界奇觀</h2><p><img src='http://www.hawkaoc.net/bbs/data/attachment/forum/dvbbs/20031071133156749.jpg'/></p><p></p><h2>置頂討論區</h2><ul class="comment"><li>雖然不是什麼公司計畫，可是我覺得我們會需要一個定期的討論。畢竟這個計畫可能不是密集衝刺一兩週就可以做好的專案。</li>
<li>我覺得每兩週（比如今天週二（6/11)，下下週就是6/25）討論一次現況與進度，如何？</li>
<li>若訂在週四可以跟g0v迷你黑客松合辦？他們通常在週四晚上</li>
<li>週四，每兩週一次，OK？ g0v 這個有在 registrano 上嗎？好像沒看到？</li>
<li>一邊都當週才開，不固定，時間通常是週四，地點是和多。週四若和多沒開，還可以亂入 H4?</li>
<li>我這邊跟 LittleQ協調的結果，我們兩個時間上是周二比較好。另外，我們可以每兩周線上&nbsp; Hangout 一次，然後每個月做一次實體 meeting</li>
<li>COSCUP 2013 簡短討論結果：雖然會有良好的資料整理準則，但我們還是允許直接丟沒有 parsed 過的 raw data，或是其他複雜的、比較不合格的格式，!因為資料庫允許可控制與有限度的混亂。</li></ul>

<h2>伐木工</h2><ul><li>littleq0903 (<a href="http://about.me/littleq)"></a><a href='http://about.me/littleq'/>http://about.me/littleq</a>)</li>
<li>hychen</li>
<li>snowmantw</li>
<li>clifflu</li>
<li>自己新增</li></ul>

<h2>專案介紹</h2><p><s>蓋滿 180 天後獲得勝利</s> 把大家需要用的共同資料整理成 Graph，讓大家自行取用。總之我們希望做一個 g0v 版的 Open Graph</p><p></p><ul><li>專案期限：當然是 180 天了</li>
<li>期間：2013/06/08 ~ 2013/12/05 (180 天）</li>
<li>工作目標：（分成N階段）</li><ol><li>先用假資料填充，模擬 Graph API 運作情形。</li>
<li>資料完成結構後再來寫 server</li>
<li>後端 stream-in 跟前端 stream-out 各 API 討論</li>
<li>各種權限控管<ol><li>stream-out clients: 如何增加 relation, object ;以及如何管理、註冊、刪除 App</li>
<li>stream-in sources: 如何增加來源，以及來源需要的屬性設定<ol><li>例如該來源的資料是 mutable 或 imutable&nbsp;</li></ol>
</ol>
</ol>
</ul>
<ul><li>狀態：填充假資料中</li>
<li>github repo: <a href="https://github.com/g0v/ww-simulation/"></a><a href='https://github.com/g0v/ww-simulation/'/>https://github.com/g0v/ww-simulation/</a></li>
<li>example api call&nbsp;<ul><li>[1] <a href="http://g0v.github.io/ww-simulation/api/1/this"></a><a href='http://g0v.github.io/ww-simulation/api/1/this'/>http://g0v.github.io/ww-simulation/api/1/this</a> (先用 this 代替空白）</li>
<li>[1 -&gt; news] <a href="http://g0v.github.io/ww-simulation/api/1/news"></a><a href='http://g0v.github.io/ww-simulation/api/1/news'/>http://g0v.github.io/ww-simulation/api/1/news</a></li></ul>
</li>
<li>Google+ Community<ul><li><a href="https://plus.google.com/communities/106694105832586671823"></a>https://plus.google.com/communities/106694105832586671823</li></ul>
</li>
<li>電腦白癡專用填資料處（畫布太小請自行增加）<ul><li><a href="https://docs.google.com/folder/d/0B0NsS2a-Qx8ZN1d2Zm95MmVSd0U/edit?docId=1zcXSNaXGT8PjlrSrMF6Cu9NxZbYHsLFBuaXaLzChaKI"></a><a href='https://docs.google.com/folder/d/0B0NsS2a-Qx8ZN1d2Zm95MmVSd0U/edit?docId=1zcXSNaXGT8PjlrSrMF6Cu9NxZbYHsLFBuaXaLzChaKI'/>https://docs.google.com/folder/d/0B0NsS2a-Qx8ZN1d2Zm95MmVSd0U/edit?docId=1zcXSNaXGT8PjlrSrMF6Cu9NxZbYHsLFBuaXaLzChaKI</a></li></ul>
</ul>

<h2>徵求夥伴</h2><ul><li>NeedTxtHacker: 需要 txt hackers 來幫忙填充假資料</li>
<li>NeedBackendDeveloper: 幫忙寫 Graph server 的 backend server</li></ul>

<h2>重要：決定 License</h2><ul><li>害人之心不可有，防人之心不可無</li>
<li>我提議只要是在這個 project 下的 code 都用 GPLv3 釋出<ul><li>當然，如果有靜態連結(應該不會？)或類似的議題就可以再討論</li></ul>
</li>
<li>要用 lqfb 討論嗎？我個人是偏好比較沒那麼嚴格的 license, 這樣有其他商業應用想要 contribute 比較不會有顧忌。要考慮防人的話，可以使用 Apache 2</li></ul>
<ul class="comment"><li>這邊或許要考慮的是我們這個專案可能怎樣被用，或被回饋。基本上只是要防止拿了我們未來開發的成果出去，然後不回饋回來。所以如果有合用的 license 可以在這邊說明。</li>
<li>老實說，我很懷疑能在 software 方面做出創舉，畢竟核心是 Graph DB ，有其難度；如果能找到先烈 frok 會比較省事。我比較期待這個平台能承載夠多、夠有彈性的資料與授權，省下大家自己爬的時間，簡化後續應用。</li>
<li>對於軟體建樹方面的意見我也覺得可能不會太大。不過我覺得這種東西就是愈早決定愈好。即使剛開始看起來似乎一點點 code 不值得在 licence 上大費周張，可是如果到時候每個人的 code 都用不同 license ，感覺相當不妙。</li></ul>

<h2>技術相關</h2><ul><li>架構圖<img src='https://hackpad-attachments.s3.amazonaws.com/g0vww.hackpad.com_0Anf3xIpVRq_p.56249_1370683920633_worldwonder.png'/></li></ul>

<ul><li>原則<ul><li>connections 應該儘量少、新增限制嚴格而足夠涵蓋大部份物件間的關係<ul><li>related:最基本的雙向關係</li>
<li>exclusively not related: 排除物件間存在其它關係的關係</li>
<li>negatively related: 存在單向關係，但是要表達負面資訊</li>
<li>unidirectional related: 單向關係</li>
<li>subset: 子集合，可以涵蓋大部份像是屬於或成員關係</li>
<li>superset: 在反向查詢時會有必要？</li>
<li>alias: 雙向關係</li>
<li>update: for immutable objects, and time-related relation; unidirectional</li></ul>
</ul>
<ul style="list-style: none;"><li><br/></li></ul>
</ul>
<ul class="comment"><li>後來設想一些使用情境發現 connection 可能還是要有一個類似「名字」的輔助欄位方便搜尋。不然同樣都是 subset，人從屬於組織跟某個計畫從屬於組織，是否不好分？當然使用者可以條件搜尋人+subset，可是如果他可以直接搜尋「隸屬於」這樣的 connection name，也許比較好用？</li></ul>

<ul><li>objects 因此種類可以隨 stream-in 能提供的各種資源而定，並應該儘量豐富化，例如<ul><li>person</li>
<li>event</li>
<li>time</li>
<li>place</li>
<li>organization</li>
<li>message</li></ul>
</li>
<li>namespace: 如果 stream-in sources 在提供資料時可以提供 namespace，比如「德國立院」「台灣立院」，這樣可以更容易的搜尋<ul><li>即使沒有 namespace，也可以透過 connections 跟 objects 去搜尋，只是使用 namespace 比較快；黑盒子應應對 namespace 與 type 索引以加速</li>
<li>事實上可以以一群 object 代表 namespace，然後連結到他們的 objects 就是屬於該 namespace 的</li></ul>
</li>
<li>objects 是可以自由增加的，隨著 stream-in 的來源增加可預想會暴量，所以<b>需要即時處理或效能吃緊的 application 應該要自建應用程式自己的 database 或 memcached 去做最佳最佳化 ，只在有需要時批次或背景處理的把資料拉回來</b></li>
<li>stream-out client 所產生的處理後資料也可以回輸成為 stream-in 的來源</li>
<li>因為只提供最 general 的格式與操作，所以進階的使用方式，部份可以包成 SDK 提供，再由其中某些函式呼叫或編譯自動生成數個基本操作</li>
<li>議題</li>
<li>可以想見物件與關聯的數目會非常多，查詢等一定要做並行化</li>
<li>真的要做可能要使用 NoSQL 或 GraphDatabase 讓 scale-out 與 CRUD 可以適合我們這計劃的用途</li>
<li>除了新聞跟立法院公報外，思考還有哪些資料來源可以被接上的，要怎麼接，以及有哪些需求 client application<ul><li>法律的連結與比對資訊？&nbsp;</li></ul>
</li>
<li>mutable/imutable&nbsp;<ul><li>對 imutable objects 來說，更新 object 的這個動作，相當於建立一個 diff 過的 patch object，然後用一個 connection 連結起來<ul><li>兼有版本管理資訊</li></ul>
</li>
<li>mutable object 的修改會有疑慮是取用該資源的 application ，在該資源更改後會需要做更新，尤其是有快取等情況</li>
<li>對於一個資源是 mutable 或 immutable，是由 stream-in 方決定的，不是由 client applications 決定</li>
<li>immutable 可以兼容於 mutable 的操作：比如要找更改後的版本，immutable 只要順著 update 的關係下找就好</li></ul>
</li>
<li>相關資源</li>
<li><a href="https://github.com/thinkaurelius/titan/wiki"></a><a href='https://github.com/thinkaurelius/titan/wiki'/>https://github.com/thinkaurelius/titan/wiki</a>&nbsp;</li></li>
<li>&quot;Titan is a distributed <a href='http://en.wikipedia.org/wiki/Graph_database'/>graph database</a> optimized for storing and querying<a href='http://en.wikipedia.org/wiki/Graph_(mathematics)'/>graphs</a> represented over a cluster of machines. &quot;</li></ul>

<h2>開發進度</h2><p><img src='http://'/></p><ul><li>目前最需要的是要去訂出我們內部要有哪些操作，以及對應的開放 APIs<ul><li>最基本的應該可以參考 graph database 去設計</li>
<li>例如：增刪改節點 (object)，增刪改連結(connection)</li>
<li>對外部而言，stream-out 方只能 GET，其他增刪改權限會在 stream-in 方手裡。當然 stream-in 各方只能增刪改自己的節點。GET則都是全域</li>
<li>系統內部對物件與連結的基本操作<ul><li>CRUD object/connection</li>
<li>compact:真正去刪除 __delete__ 物件 subset 下的物件</li>
<li>diff: for object</li>
<li>由基本操作衍生的進階操作<ul><li>immutable-update on object<ul><li>read current version</li>
<li>diff &lt;new&gt; &lt;current&gt;</li>
<li>create patch object</li>
<li>create connection &lt;update&gt; between &lt;patch&gt; and &lt;current&gt; object</li></ul>
</li></ul>
</li></ul>
</li>
<li>系統外部可進行的操作與如何映射至內部操作描述<ul><li>stream-in: PUT /id<ul><li>如果目標是物件且是 mutable，則直接修改</li>
<li>如果目標是物件且是 immutable，則增加一個 update 連結，與新 PUT 版本的物件。這個連結會把新舊版連結起來<ul><li>理論上比較好的作法是只存比較差異後的 diff 資訊</li>
<li>如果有 PATCH method 就更適合用 diff 了</li></ul>
</li>
<li>如果目標是連結，直接更改該連結<ul><li>連結會被改動應該只有刪除與新增比較常見，更改內容似乎用途不大？</li></ul>
</li></ul>
</li>
<li>stream-in: DELETE /id<ul><li>標記為要刪除，實際上等背後使用 compact 時才刪除</li>
<li>可以全部連結到一個叫 __delete__ 的 primary object instance</li>
<li>但如果目標是連結，直接刪除。因為沒有物件-連結-連結，只有物件-連結-物件</li></ul>
</li>
<li>stream-in: POST &lt;object JSON&gt; /objects<ul><li>新增物件</li></ul>
</li>
<li>stream-in: POST &lt;post JSON&gt; /connections<ul><li>新增連結</li></ul>
</li>
<li>stream-in/stream-out: GET /&lt;object&gt;/&lt;connection&gt;<ul><li>取得某物件與其指定型別的連結<ul><li>例如：GET /gazette-dialog-001/subset，取得某段公報對話被屬於哪些資源?</li></ul>
</li></ul>
</li>
<li>stream-in/stream-out: POST /search?q...<ul><li>參考 search in RESTful 的設計原則：<a href="http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api?hn"></a><a href='http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api?hn'/>http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api?hn</a></li>
<li>search 實際上不應該是系統內建功能。而是要像 C++ iterator 那樣是外置的</li></ul>
</li></ul>
</li>
<li>註冊與管理各 stream-in 與 stream-out相關功能/頁面/APIs<ul><li>stream-in 與 stream-out 本身相關資訊也可以 object-connection 的方式儲存</li>
<li>不過或許 metadata 還是額外放一個資料庫比較好</li></ul>
</li>
<li>物件的基本屬性欄位(<b>這還真適合用 Haskell 寫...</b>)<ul><li>mutable: Boolean ::物件是否可被修改</li>
<li>proxy: URL|EmptyURL ::是否代理某個資源。代理資源意味著 content 不會存在我們自己的 persistent server 中。如果是 EmptyURL 則代表不是</li>
<li>content: Data ::以 JSON 格式來說，就是 Object, Array, Primary Values 等</li>
<li>type: String ::由 stream-in 所決定的資源型別，例如 person, event 等</li>
<li>id: ObjectId</li></ul>
</li>
<li>連結的基本屬性欄位<ul><li>type: Related|NotRelated|NegRelated|UniRelated|Subset|Alias|Update</li>
<li>from: ObjectId ::單向來說，箭頭的開始目標</li>
<li>to: ObjectId ::單向來說，箭頭的結束目標</li></ul>
</li>
<li>primary object instances<ul><li>__delete__: 與此物件相關連 ( subset ) 代表該物件日後將會被真正刪除</li></ul>
</li></ul>
</li>
<li>接著是去看實作的目標，是如何配合著實作出我們所需要的操作</li>
<li>可以同步進行刻出 stream-in 與 stream-out 兩邊的 APIs&nbsp;</li></ul>

<ul class="comment"><li>所以其實這東西就是像 Django 那樣中間的 framework，提供對外與對內 (persistent system)的操作</li>
<li>具體來說就是下列這幾種組件：<ul class="comment"><li>對外 APIs 相關者，如 router 跟 request/response handlers</li>
<li>對各種不同 persistent system 的 adapters ，如 MySQL adapter 跟 Neo4j adapter。adapters 即是對內操作如增刪 objects 等程式實作處</li>
<li>帳號與權限管理</li>
<li>搜尋與其他需要內建或可擴充之演算法 plugins</li>
<li>註冊與管理 stream-in 跟 stream-out 之功能</li>
<li>metadata database</li>
<li>commandline/web interface management tools</li></ul>
</ul>

<h2>後端考慮</h2><p>先列出一些可能的後端，在看上面 spec 發展選擇適當的，列出優缺：</p><ul><li><a href="http://www.neo4j.org/"></a>http://www.neo4j.org/</li>
<li>postgresql: 有奇怪的 sql-fu 的話，就可以作很多 graph query. 9.3 又可以把常見需要 traverse 的，變成 materialized view. 可參考: <a href="http://www.slideshare.net/quipo/rdbms-in-the-social-networks-age"></a>http://www.slideshare.net/quipo/rdbms-in-the-social-networks-age</li>
<li><a href="http://thinkaurelius.github.io/titan/"></a>http://thinkaurelius.github.io/titan/<ul><li>base on cassendra or hbase(雖然對我來說，cassandra 的好處之一是裝起來比較簡單...) : <a href="http://oss-tw.blogspot.tw/2010/04/hbase-vs-cassandra.html"></a>http://oss-tw.blogspot.tw/2010/04/hbase-vs-cassandra.html<a href='http://oss-tw.blogspot.tw/2010/04/hbase-vs-cassandra.html'/>&nbsp;</a></li></ul>
</li>
<li>今天有查到資料說 Redis 也有 graph 式的操作方式，還有就是如果不是真的需要 graph ，可以用已經有的 wrapper 去作：<a href="http://stackoverflow.com/questions/9302295/nosql-solution-for-persisting-graphs-at-scale"></a>http://stackoverflow.com/questions/9302295/nosql-solution-for-persisting-graphs-at-scale</li>
<li>國網中心有 Hadoop 實驗平台 <a href="http://hadoop.nchc.org.tw/"></a>http://hadoop.nchc.org.tw/。如果像 Titan 可以使用 HBase 做 backend 在上面也許不錯？只是要有門路就是了</li></ul>

<ul class="comment"><li>我覺得我可以開始架設 graph database 去作分散式運算等測試，先把佈署與系統相關的部份熟悉好。與此同時，LittleQ 可以開始用像 Redis 做小型的版本</li>
<li>我有些用Neo4j資料庫的經驗，做過一些跟人與人資料關聯的分析系統</li></ul>

<p>wikipedia graph database: <a href="http://en.wikipedia.org/wiki/Graph_database"></a>http://en.wikipedia.org/wiki/Graph_database</p><p></p><p></p><h2>Stream-in 資料來源</h2><ul><li>未經整理的現有資料完全由人工或程式去剖析成關係圖是很累的事情。我覺得需要做一個視覺化工具，去幫助現有資料從&nbsp; JSON 轉成 物件-關係圖<ul><li>Ex: {&quot;gov-organization&quot;: [ {&nbsp; &quot;person&quot;: &quot;M19&quot;, &quot;title&quot;: &quot;President&quot;, &quot;since&quot;: &quot;2011&quot;&nbsp; } ] }</li></ul>
<ul style="list-style: none;"><li>要輔助在 &quot;gov-organization&quot; 跟其子元素中建立關係。比如 subset；</li>
<li>而且是每個陣列中的元素都需要變成 &quot;gov-organization&quot; subset，</li>
<li>至少涉及自動展開、自動關聯</li></ul>
<ul><li>應該要有一個工具可以用拖拉的方式建立兩者之間的關係，並可以修改</li></ul>
</ul>

<h2>Stream-out 應用程式</h2><p></p></body>
</html>
